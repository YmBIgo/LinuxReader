{
    "content": {
        "functionName": "__latent_entropy struct task_struct *copy_process(",
        "functionCodeLine": "__latent_entropy struct task_struct *copy_process(",
        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
        "functionCodeContent": "__latent_entropy struct task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tconst u64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t/*\n\t * Don't allow sharing the root directory with processes in a different\n\t * namespace\n\t */\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t/*\n\t\t * - CLONE_DETACHED is blocked so that we can potentially\n\t\t *   reuse it later for CLONE_PIDFD.\n\t\t */\n\t\tif (clone_flags & CLONE_DETACHED)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * Force any signals received before this point to be delivered\n\t * before the fork happens.  Collect up signals sent to multiple\n\t * processes that happen during the fork and delay them so that\n\t * they appear to happen after the fork.\n\t */\n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (task_sigpending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\tp->flags &= ~PF_KTHREAD;\n\tif (args->kthread)\n\t\tp->flags |= PF_KTHREAD;\n\tif (args->user_worker) {\n\t\t/*\n\t\t * Mark us a user worker, and block any signal that isn't\n\t\t * fatal or STOP\n\t\t */\n\t\tp->flags |= PF_USER_WORKER;\n\t\tsiginitsetinv(&p->blocked, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t}\n\tif (args->io_thread)\n\t\tp->flags |= PF_IO_WORKER;\n\n\tif (args->name)\n\t\tstrscpy_pad(p->comm, args->name, sizeof(p->comm));\n\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\tretval = -EAGAIN;\n\tif (is_rlimit_overlimit(task_ucounts(p), UCOUNT_RLIMIT_NPROC, rlimit(RLIMIT_NPROC))) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_cleanup_count;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE | PF_NO_SETAFFINITY);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\ttick_dep_init_task(p);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n\tif (args->kthread) {\n\t\tif (!set_kthread_struct(p))\n\t\t\tgoto bad_fork_cleanup_delayacct;\n\t}\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_delayacct;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n#ifdef CONFIG_BPF_SYSCALL\n\tRCU_INIT_POINTER(p->bpf_storage, NULL);\n\tp->bpf_ctx = NULL;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_sched_cancel_fork;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p, args->no_files);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(p, args);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t/*\n\t * This has to happen after we've potentially unshared the file\n\t * descriptor table (so that the pidfd doesn't leak into the child\n\t * if the fd table isn't shared).\n\t */\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tint flags = (clone_flags & CLONE_THREAD) ? PIDFD_THREAD : 0;\n\n\t\t/*\n\t\t * Note that no task has been attached to @pid yet indicate\n\t\t * that via CLONE_PIDFD.\n\t\t */\n\t\tretval = pidfd_prepare(pid, flags | PIDFD_STALE, &pidfile);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\t\tpidfd = retval;\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_task_syscall_work(p, SYSCALL_TRACE);\n#if defined(CONFIG_GENERIC_ENTRY) || defined(TIF_SYSCALL_EMU)\n\tclear_task_syscall_work(p, SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tp->task_works = NULL;\n\tclear_posix_cputimers_work(p);\n\n#ifdef CONFIG_KRETPROBES\n\tp->kretprobe_instances.first = NULL;\n#endif\n#ifdef CONFIG_RETHOOK\n\tp->rethooks.first = NULL;\n#endif\n\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t/*\n\t * Now that the cgroups are pinned, re-clone the parent cgroup and put\n\t * the new task on the correct runqueue. All this *before* the task\n\t * becomes visible.\n\t *\n\t * This isn't part of ->can_fork() because while the re-cloning is\n\t * cgroup specific, it unconditionally needs to place the task on a\n\t * runqueue.\n\t */\n\tretval = sched_cgroup_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_cancel_cgroup;\n\n\t/*\n\t * Allocate a default futex hash for the user process once the first\n\t * thread spawns.\n\t */\n\tif (need_futex_hash_allocate_default(clone_flags)) {\n\t\tretval = futex_hash_allocate_default();\n\t\tif (retval)\n\t\t\tgoto bad_fork_core_free;\n\t\t/*\n\t\t * If we fail beyond this point we don't free the allocated\n\t\t * futex hash map. We assume that another thread will be created\n\t\t * and makes use of it. The hash map will be freed once the main\n\t\t * thread terminates.\n\t\t */\n\t}\n\t/*\n\t * From this point on we must avoid any synchronous user-space\n\t * communication until we take the tasklist-lock. In particular, we do\n\t * not want user-space to be able to predict the process start-time by\n\t * stalling fork(2) after we recorded the start_time but before it is\n\t * visible to the system.\n\t */\n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tp->exit_signal = -1;\n\t\telse\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t\tp->exit_signal = args->exit_signal;\n\t}\n\n\tklp_copy_process(p);\n\n\tsched_core_fork(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\trv_task_fork(p);\n\n\trseq_fork(p, clone_flags);\n\n\t/* Don't start children in a dying pid namespace */\n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_core_free;\n\t}\n\n\t/* Let kill terminate clone/fork in the middle */\n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_core_free;\n\t}\n\n\t/* No more failure paths after this point. */\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tcurrent->signal->quick_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\tuser_events_fork(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_core_free:\n\tsched_core_free(p);\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\nbad_fork_cancel_cgroup:\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_sched_cancel_fork:\n\tsched_cancel_fork(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\n#endif\nbad_fork_cleanup_delayacct:\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tdec_rlimit_ucounts(task_ucounts(p), UCOUNT_RLIMIT_NPROC, 1);\n\texit_creds(p);\nbad_fork_free:\n\tWRITE_ONCE(p->__state, TASK_DEAD);\n\texit_task_stack_account(p);\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}",
        "id": "f1c8e3279962d18e1bef89fa"
    },
    "children": [
        {
            "content": {
                "functionName": "copy_mm",
                "functionCodeLine": "retval = copy_mm(clone_flags, p);",
                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                "id": "c2bc4ce3db24d5ab0f911785",
                "functionCodeContent": "static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n\ttsk->last_switch_time = 0;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t} else {\n\t\tmm = dup_mm(tsk, current->mm);\n\t\tif (!mm)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tsched_mm_cid_fork(tsk);\n\treturn 0;\n}"
            },
            "children": [
                {
                    "content": {
                        "functionName": "dup_mm",
                        "functionCodeLine": "mm = dup_mm(tsk, current->mm);",
                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                        "id": "9ae12162fa02260bb4368199",
                        "functionCodeContent": "static struct mm_struct *dup_mm(struct task_struct *tsk,\n\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\tmm = allocate_mm();\n\tif (!mm)\n\t\tgoto fail_nomem;\n\n\tmemcpy(mm, oldmm, sizeof(*mm));\n\n\tif (!mm_init(mm, tsk, mm->user_ns))\n\t\tgoto fail_nomem;\n\n\tuprobe_start_dup_mmap();\n\terr = dup_mmap(mm, oldmm);\n\tif (err)\n\t\tgoto free_pt;\n\tuprobe_end_dup_mmap();\n\n\tmm->hiwater_rss = get_mm_rss(mm);\n\tmm->hiwater_vm = mm->total_vm;\n\n\tif (mm->binfmt && !try_module_get(mm->binfmt->module))\n\t\tgoto free_pt;\n\n\treturn mm;\n\nfree_pt:\n\t/* don't put binfmt in mmput, we haven't got module yet */\n\tmm->binfmt = NULL;\n\tmm_init_owner(mm, NULL);\n\tmmput(mm);\n\tif (err)\n\t\tuprobe_end_dup_mmap();\n\nfail_nomem:\n\treturn NULL;\n}"
                    },
                    "children": [
                        {
                            "content": {
                                "functionName": "allocate_mm",
                                "functionCodeLine": "mm = allocate_mm();",
                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                                "id": "8035326fac1a5d881fffc560"
                            },
                            "children": []
                        },
                        {
                            "content": {
                                "functionName": "dup_mmap",
                                "functionCodeLine": "err = dup_mmap(mm, oldmm);",
                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/mmap.c",
                                "id": "eed52385cacb2dfe5e9ba1c6",
                                "functionCodeContent": "__latent_entropy int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n\tstruct vm_area_struct *mpnt, *tmp;\n\tint retval;\n\tunsigned long charge = 0;\n\tLIST_HEAD(uf);\n\tVMA_ITERATOR(vmi, mm, 0);\n\n\tif (mmap_write_lock_killable(oldmm))\n\t\treturn -EINTR;\n\tflush_cache_dup_mm(oldmm);\n\tuprobe_dup_mmap(oldmm, mm);\n\t/*\n\t * Not linked in yet - no deadlock potential:\n\t */\n\tmmap_write_lock_nested(mm, SINGLE_DEPTH_NESTING);\n\n\t/* No ordering required: file already has been exposed. */\n\tdup_mm_exe_file(mm, oldmm);\n\n\tmm->total_vm = oldmm->total_vm;\n\tmm->data_vm = oldmm->data_vm;\n\tmm->exec_vm = oldmm->exec_vm;\n\tmm->stack_vm = oldmm->stack_vm;\n\n\t/* Use __mt_dup() to efficiently build an identical maple tree. */\n\tretval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);\n\tif (unlikely(retval))\n\t\tgoto out;\n\n\tmt_clear_in_rcu(vmi.mas.tree);\n\tfor_each_vma(vmi, mpnt) {\n\t\tstruct file *file;\n\n\t\tvma_start_write(mpnt);\n\t\tif (mpnt->vm_flags & VM_DONTCOPY) {\n\t\t\tretval = vma_iter_clear_gfp(&vmi, mpnt->vm_start,\n\t\t\t\t\t\t    mpnt->vm_end, GFP_KERNEL);\n\t\t\tif (retval)\n\t\t\t\tgoto loop_out;\n\n\t\t\tvm_stat_account(mm, mpnt->vm_flags, -vma_pages(mpnt));\n\t\t\tcontinue;\n\t\t}\n\t\tcharge = 0;\n\t\t/*\n\t\t * Don't duplicate many vmas if we've been oom-killed (for\n\t\t * example)\n\t\t */\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tretval = -EINTR;\n\t\t\tgoto loop_out;\n\t\t}\n\t\tif (mpnt->vm_flags & VM_ACCOUNT) {\n\t\t\tunsigned long len = vma_pages(mpnt);\n\n\t\t\tif (security_vm_enough_memory_mm(oldmm, len)) /* sic */\n\t\t\t\tgoto fail_nomem;\n\t\t\tcharge = len;\n\t\t}\n\n\t\ttmp = vm_area_dup(mpnt);\n\t\tif (!tmp)\n\t\t\tgoto fail_nomem;\n\t\tretval = vma_dup_policy(mpnt, tmp);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_policy;\n\t\ttmp->vm_mm = mm;\n\t\tretval = dup_userfaultfd(tmp, &uf);\n\t\tif (retval)\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tif (tmp->vm_flags & VM_WIPEONFORK) {\n\t\t\t/*\n\t\t\t * VM_WIPEONFORK gets a clean slate in the child.\n\t\t\t * Don't prepare anon_vma until fault since we don't\n\t\t\t * copy page for current vma.\n\t\t\t */\n\t\t\ttmp->anon_vma = NULL;\n\t\t} else if (anon_vma_fork(tmp, mpnt))\n\t\t\tgoto fail_nomem_anon_vma_fork;\n\t\tvm_flags_clear(tmp, VM_LOCKED_MASK);\n\t\t/*\n\t\t * Copy/update hugetlb private vma information.\n\t\t */\n\t\tif (is_vm_hugetlb_page(tmp))\n\t\t\thugetlb_dup_vma_private(tmp);\n\n\t\t/*\n\t\t * Link the vma into the MT. After using __mt_dup(), memory\n\t\t * allocation is not necessary here, so it cannot fail.\n\t\t */\n\t\tvma_iter_bulk_store(&vmi, tmp);\n\n\t\tmm->map_count++;\n\n\t\tif (tmp->vm_ops && tmp->vm_ops->open)\n\t\t\ttmp->vm_ops->open(tmp);\n\n\t\tfile = tmp->vm_file;\n\t\tif (file) {\n\t\t\tstruct address_space *mapping = file->f_mapping;\n\n\t\t\tget_file(file);\n\t\t\ti_mmap_lock_write(mapping);\n\t\t\tif (vma_is_shared_maywrite(tmp))\n\t\t\t\tmapping_allow_writable(mapping);\n\t\t\tflush_dcache_mmap_lock(mapping);\n\t\t\t/* insert tmp into the share list, just after mpnt */\n\t\t\tvma_interval_tree_insert_after(tmp, mpnt,\n\t\t\t\t\t&mapping->i_mmap);\n\t\t\tflush_dcache_mmap_unlock(mapping);\n\t\t\ti_mmap_unlock_write(mapping);\n\t\t}\n\n\t\tif (!(tmp->vm_flags & VM_WIPEONFORK))\n\t\t\tretval = copy_page_range(tmp, mpnt);\n\n\t\tif (retval) {\n\t\t\tmpnt = vma_next(&vmi);\n\t\t\tgoto loop_out;\n\t\t}\n\t}\n\t/* a new mm has just been created */\n\tretval = arch_dup_mmap(oldmm, mm);\nloop_out:\n\tvma_iter_free(&vmi);\n\tif (!retval) {\n\t\tmt_set_in_rcu(vmi.mas.tree);\n\t\tksm_fork(mm, oldmm);\n\t\tkhugepaged_fork(mm, oldmm);\n\t} else {\n\n\t\t/*\n\t\t * The entire maple tree has already been duplicated. If the\n\t\t * mmap duplication fails, mark the failure point with\n\t\t * XA_ZERO_ENTRY. In exit_mmap(), if this marker is encountered,\n\t\t * stop releasing VMAs that have not been duplicated after this\n\t\t * point.\n\t\t */\n\t\tif (mpnt) {\n\t\t\tmas_set_range(&vmi.mas, mpnt->vm_start, mpnt->vm_end - 1);\n\t\t\tmas_store(&vmi.mas, XA_ZERO_ENTRY);\n\t\t\t/* Avoid OOM iterating a broken tree */\n\t\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n\t\t}\n\t\t/*\n\t\t * The mm_struct is going to exit, but the locks will be dropped\n\t\t * first.  Set the mm_struct as unstable is advisable as it is\n\t\t * not fully initialised.\n\t\t */\n\t\tset_bit(MMF_UNSTABLE, &mm->flags);\n\t}\nout:\n\tmmap_write_unlock(mm);\n\tflush_tlb_mm(oldmm);\n\tmmap_write_unlock(oldmm);\n\tif (!retval)\n\t\tdup_userfaultfd_complete(&uf);\n\telse\n\t\tdup_userfaultfd_fail(&uf);\n\treturn retval;\n\nfail_nomem_anon_vma_fork:\n\tmpol_put(vma_policy(tmp));\nfail_nomem_policy:\n\tvm_area_free(tmp);\nfail_nomem:\n\tretval = -ENOMEM;\n\tvm_unacct_memory(charge);\n\tgoto loop_out;\n}"
                            },
                            "children": [
                                {
                                    "content": {
                                        "functionName": "__mt_dup",
                                        "functionCodeLine": "retval = __mt_dup(&oldmm->mm_mt, &mm->mm_mt, GFP_KERNEL);",
                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/mmap.c",
                                        "id": "a5416cd238d1c2fea3ad600e"
                                    },
                                    "children": []
                                },
                                {
                                    "content": {
                                        "functionName": "vm_area_dup",
                                        "functionCodeLine": "tmp = vm_area_dup(mpnt);",
                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/mmap.c",
                                        "id": "ac9acc6c8ae45e30252f79dc"
                                    },
                                    "children": []
                                },
                                {
                                    "content": {
                                        "functionName": "copy_page_range",
                                        "functionCodeLine": "retval = copy_page_range(tmp, mpnt);",
                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                        "id": "84ee1bb3d72a2f0bbab07a5d",
                                        "functionCodeContent": "copy_page_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma)\n{\n\tpgd_t *src_pgd, *dst_pgd;\n\tunsigned long addr = src_vma->vm_start;\n\tunsigned long end = src_vma->vm_end;\n\tstruct mm_struct *dst_mm = dst_vma->vm_mm;\n\tstruct mm_struct *src_mm = src_vma->vm_mm;\n\tstruct mmu_notifier_range range;\n\tunsigned long next;\n\tbool is_cow;\n\tint ret;\n\n\tif (!vma_needs_copy(dst_vma, src_vma))\n\t\treturn 0;\n\n\tif (is_vm_hugetlb_page(src_vma))\n\t\treturn copy_hugetlb_page_range(dst_mm, src_mm, dst_vma, src_vma);\n\n\t/*\n\t * We need to invalidate the secondary MMU mappings only when\n\t * there could be a permission downgrade on the ptes of the\n\t * parent mm. And a permission downgrade will only happen if\n\t * is_cow_mapping() returns true.\n\t */\n\tis_cow = is_cow_mapping(src_vma->vm_flags);\n\n\tif (is_cow) {\n\t\tmmu_notifier_range_init(&range, MMU_NOTIFY_PROTECTION_PAGE,\n\t\t\t\t\t0, src_mm, addr, end);\n\t\tmmu_notifier_invalidate_range_start(&range);\n\t\t/*\n\t\t * Disabling preemption is not needed for the write side, as\n\t\t * the read side doesn't spin, but goes to the mmap_lock.\n\t\t *\n\t\t * Use the raw variant of the seqcount_t write API to avoid\n\t\t * lockdep complaining about preemptibility.\n\t\t */\n\t\tvma_assert_write_locked(src_vma);\n\t\traw_write_seqcount_begin(&src_mm->write_protect_seq);\n\t}\n\n\tret = 0;\n\tdst_pgd = pgd_offset(dst_mm, addr);\n\tsrc_pgd = pgd_offset(src_mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\tif (pgd_none_or_clear_bad(src_pgd))\n\t\t\tcontinue;\n\t\tif (unlikely(copy_p4d_range(dst_vma, src_vma, dst_pgd, src_pgd,\n\t\t\t\t\t    addr, next))) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t} while (dst_pgd++, src_pgd++, addr = next, addr != end);\n\n\tif (is_cow) {\n\t\traw_write_seqcount_end(&src_mm->write_protect_seq);\n\t\tmmu_notifier_invalidate_range_end(&range);\n\t}\n\treturn ret;\n}"
                                    },
                                    "children": [
                                        {
                                            "content": {
                                                "functionName": "copy_p4d_range",
                                                "functionCodeLine": "if (unlikely(copy_p4d_range(dst_vma, src_vma, dst_pgd, src_pgd,",
                                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                "id": "5282cdb3e81096f6bb0ca253",
                                                "functionCodeContent": "copy_p4d_range(struct vm_area_struct *dst_vma, struct vm_area_struct *src_vma,\n\t       pgd_t *dst_pgd, pgd_t *src_pgd, unsigned long addr,\n\t       unsigned long end)\n{\n\tstruct mm_struct *dst_mm = dst_vma->vm_mm;\n\tp4d_t *src_p4d, *dst_p4d;\n\tunsigned long next;\n\n\tdst_p4d = p4d_alloc(dst_mm, dst_pgd, addr);\n\tif (!dst_p4d)\n\t\treturn -ENOMEM;\n\tsrc_p4d = p4d_offset(src_pgd, addr);\n\tdo {\n\t\tnext = p4d_addr_end(addr, end);\n\t\tif (p4d_none_or_clear_bad(src_p4d))\n\t\t\tcontinue;\n\t\tif (copy_pud_range(dst_vma, src_vma, dst_p4d, src_p4d,\n\t\t\t\t   addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_p4d++, src_p4d++, addr = next, addr != end);\n\treturn 0;\n}"
                                            },
                                            "children": [
                                                {
                                                    "content": {
                                                        "functionName": "copy_pud_range",
                                                        "functionCodeLine": "if (copy_pud_range(dst_vma, src_vma, dst_p4d, src_p4d,",
                                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                        "id": "27b1b2fc0ca4580fccf96d67"
                                                    },
                                                    "children": []
                                                },
                                                {
                                                    "content": {
                                                        "functionName": "p4d_alloc",
                                                        "functionCodeLine": "dst_p4d = p4d_alloc(dst_mm, dst_pgd, addr);",
                                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                        "id": "374bf6c7be0e13c6dbdd80a8"
                                                    },
                                                    "children": []
                                                },
                                                {
                                                    "content": {
                                                        "functionName": "p4d_offset",
                                                        "functionCodeLine": "src_p4d = p4d_offset(src_pgd, addr);",
                                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                        "id": "0ed0642c7f3da493e19d113a"
                                                    },
                                                    "children": []
                                                },
                                                {
                                                    "content": {
                                                        "functionName": "p4d_none_or_clear_bad",
                                                        "functionCodeLine": "if (p4d_none_or_clear_bad(src_p4d))",
                                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                        "id": "303d2ae589cb8d043e871b8a"
                                                    },
                                                    "children": []
                                                },
                                                {
                                                    "content": {
                                                        "functionName": "p4d_addr_end",
                                                        "functionCodeLine": "next = p4d_addr_end(addr, end);",
                                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                        "id": "525ded4222a7951def479821"
                                                    },
                                                    "children": []
                                                }
                                            ]
                                        },
                                        {
                                            "content": {
                                                "functionName": "copy_hugetlb_page_range",
                                                "functionCodeLine": "return copy_hugetlb_page_range(dst_mm, src_mm, dst_vma, src_vma);",
                                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                "id": "f074bbab4a44bdea06466c4c"
                                            },
                                            "children": []
                                        },
                                        {
                                            "content": {
                                                "functionName": "vma_needs_copy",
                                                "functionCodeLine": "if (!vma_needs_copy(dst_vma, src_vma))",
                                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                "id": "7f7670c9ac569c2b74ea3c1c"
                                            },
                                            "children": []
                                        },
                                        {
                                            "content": {
                                                "functionName": "is_cow_mapping",
                                                "functionCodeLine": "is_cow = is_cow_mapping(src_vma->vm_flags);",
                                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                "id": "e4edae9c7661995c9fa978b1"
                                            },
                                            "children": []
                                        },
                                        {
                                            "content": {
                                                "functionName": "pgd_offset",
                                                "functionCodeLine": "dst_pgd = pgd_offset(dst_mm, addr);",
                                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/memory.c",
                                                "id": "a8ee2709212e88a29d53a8ba"
                                            },
                                            "children": []
                                        }
                                    ]
                                },
                                {
                                    "content": {
                                        "functionName": "anon_vma_fork",
                                        "functionCodeLine": "} else if (anon_vma_fork(tmp, mpnt))",
                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/mmap.c",
                                        "id": "a029ec65d596b7e500592536"
                                    },
                                    "children": []
                                },
                                {
                                    "content": {
                                        "functionName": "dup_mm_exe_file",
                                        "functionCodeLine": "dup_mm_exe_file(mm, oldmm);",
                                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/mm/mmap.c",
                                        "id": "112d89bbd13abd4e07feb63e"
                                    },
                                    "children": []
                                }
                            ]
                        },
                        {
                            "content": {
                                "functionName": "mm_init",
                                "functionCodeLine": "if (!mm_init(mm, tsk, mm->user_ns))",
                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                                "id": "3badfdf90a5fe03e55ce7415"
                            },
                            "children": []
                        },
                        {
                            "content": {
                                "functionName": "memcpy",
                                "functionCodeLine": "memcpy(mm, oldmm, sizeof(*mm));",
                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                                "id": "2ecb44795ed3c4c2e5074bd2"
                            },
                            "children": []
                        },
                        {
                            "content": {
                                "functionName": "get_mm_rss",
                                "functionCodeLine": "mm->hiwater_rss = get_mm_rss(mm);",
                                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                                "id": "ece15485477faa1aacab80c1"
                            },
                            "children": []
                        }
                    ]
                },
                {
                    "content": {
                        "functionName": "mmget",
                        "functionCodeLine": "mmget(oldmm);",
                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                        "id": "9dfc1b454841bad71e6e01b4"
                    },
                    "children": []
                },
                {
                    "content": {
                        "functionName": "sched_mm_cid_fork",
                        "functionCodeLine": "sched_mm_cid_fork(tsk);",
                        "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                        "id": "f8ec89175b56c85e55f9d152"
                    },
                    "children": []
                }
            ]
        },
        {
            "content": {
                "functionName": "dup_task_struct",
                "functionCodeLine": "p = dup_task_struct(current, node);",
                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                "id": "bb62b341b807b4390d729c9a"
            },
            "children": []
        },
        {
            "content": {
                "functionName": "mm_clear_owner",
                "functionCodeLine": "mm_clear_owner(p->mm, p);",
                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                "id": "9922f8b0785abbf52ac700fb"
            },
            "children": []
        },
        {
            "content": {
                "functionName": "mmput",
                "functionCodeLine": "mmput(p->mm);",
                "originalFilePath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
                "id": "dde956f1844cb43ea81c1c1c"
            },
            "children": []
        }
    ],
    "purpose": "copy_processがmmをどうコピーしているか知りたい",
    "rootPath": "/Users/kazuyakurihara/Documents/open_source/linux/linux/kernel/fork.c",
    "rootFunctionName": "__latent_entropy struct task_struct *copy_process("
}