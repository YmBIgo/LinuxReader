[
    {
        "line": 816,
        "character": 0,
        "functionName": "load_elf_binary",
        "firstLine": "static int load_elf_binary(struct linux_binprm *bprm)",
        "content": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n\tunsigned long load_bias = 0, phdr_addr = 0;\n\tint first_pt_load = 1;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tstruct elf_phdr *elf_property_phdata = NULL;\n\tunsigned long elf_brk;\n\tbool brk_moved = false;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long e_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct elfhdr *elf_ex = (struct elfhdr *)bprm->buf;\n\tstruct elfhdr *interp_elf_ex = NULL;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\tstruct mm_struct *mm;\n\tstruct pt_regs *regs;\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (elf_ex->e_type != ET_EXEC && elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(elf_ex))\n\t\tgoto out;\n\tif (elf_check_fdpic(elf_ex))\n\t\tgoto out;\n\tif (!can_mmap_file(bprm->file))\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tchar *elf_interpreter;\n\n\t\tif (elf_ppnt->p_type == PT_GNU_PROPERTY) {\n\t\t\telf_property_phdata = elf_ppnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (elf_ppnt->p_type != PT_INTERP)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is the program interpreter used for shared libraries -\n\t\t * for now assume that this is an a.out format binary.\n\t\t */\n\t\tretval = -ENOEXEC;\n\t\tif (elf_ppnt->p_filesz > PATH_MAX || elf_ppnt->p_filesz < 2)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = -ENOMEM;\n\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz, GFP_KERNEL);\n\t\tif (!elf_interpreter)\n\t\t\tgoto out_free_ph;\n\n\t\tretval = elf_read(bprm->file, elf_interpreter, elf_ppnt->p_filesz,\n\t\t\t\t  elf_ppnt->p_offset);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_interp;\n\t\t/* make sure path is NULL terminated */\n\t\tretval = -ENOEXEC;\n\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\u0000')\n\t\t\tgoto out_free_interp;\n\n\t\tinterpreter = open_exec(elf_interpreter);\n\t\tkfree(elf_interpreter);\n\t\tretval = PTR_ERR(interpreter);\n\t\tif (IS_ERR(interpreter))\n\t\t\tgoto out_free_ph;\n\n\t\t/*\n\t\t * If the binary is not readable then enforce mm->dumpable = 0\n\t\t * regardless of the interpreter's permissions.\n\t\t */\n\t\twould_dump(bprm, interpreter);\n\n\t\tinterp_elf_ex = kmalloc(sizeof(*interp_elf_ex), GFP_KERNEL);\n\t\tif (!interp_elf_ex) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_free_file;\n\t\t}\n\n\t\t/* Get the exec headers */\n\t\tretval = elf_read(interpreter, interp_elf_ex,\n\t\t\t\t  sizeof(*interp_elf_ex), 0);\n\t\tif (retval < 0)\n\t\t\tgoto out_free_dentry;\n\n\t\tbreak;\n\nout_free_interp:\n\t\tkfree(elf_interpreter);\n\t\tgoto out_free_ph;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < elf_ex->e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(interp_elf_ex->e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(interp_elf_ex) ||\n\t\t    elf_check_fdpic(interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_property_phdata = NULL;\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_GNU_PROPERTY:\n\t\t\t\telf_property_phdata = elf_ppnt;\n\t\t\t\tbreak;\n\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\tretval = parse_elf_properties(interpreter ?: bprm->file,\n\t\t\t\t      elf_property_phdata, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(elf_ex,\n\t\t\t\t!!interpreter, interp_elf_ex,\n\t\t\t\t&arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = begin_new_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(*elf_ex, &arch_state);\n\tif (elf_read_implies_exec(*elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tconst int snapshot_randomize_va_space = READ_ONCE(randomize_va_space);\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && snapshot_randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < elf_ex->e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot, elf_flags;\n\t\tunsigned long k, vaddr;\n\t\tunsigned long total_size = 0;\n\t\tunsigned long alignment;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\telf_prot = make_prot(elf_ppnt->p_flags, &arch_state,\n\t\t\t\t     !!interpreter, false);\n\n\t\telf_flags = MAP_PRIVATE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\t/*\n\t\t * The first time through the loop, first_pt_load is true:\n\t\t * layout will be calculated. Once set, use MAP_FIXED since\n\t\t * we know we've already safely mapped the entire region with\n\t\t * MAP_FIXED_NOREPLACE in the once-per-binary logic following.\n\t\t */\n\t\tif (!first_pt_load) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (elf_ex->e_type == ET_EXEC) {\n\t\t\t/*\n\t\t\t * This logic is run once for the first LOAD Program\n\t\t\t * Header for ET_EXEC binaries. No special handling\n\t\t\t * is needed.\n\t\t\t */\n\t\t\telf_flags |= MAP_FIXED_NOREPLACE;\n\t\t} else if (elf_ex->e_type == ET_DYN) {\n\t\t\t/*\n\t\t\t * This logic is run once for the first LOAD Program\n\t\t\t * Header for ET_DYN binaries to calculate the\n\t\t\t * randomization (load_bias) for all the LOAD\n\t\t\t * Program Headers.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Calculate the entire size of the ELF mapping\n\t\t\t * (total_size), used for the initial mapping,\n\t\t\t * due to load_addr_set which is set to true later\n\t\t\t * once the initial mapping is performed.\n\t\t\t *\n\t\t\t * Note that this is only sensible when the LOAD\n\t\t\t * segments are contiguous (or overlapping). If\n\t\t\t * used for LOADs that are far apart, this would\n\t\t\t * cause the holes between LOADs to be mapped,\n\t\t\t * running the risk of having the mapping fail,\n\t\t\t * as it would be larger than the ELF file itself.\n\t\t\t *\n\t\t\t * As a result, only ET_DYN does this, since\n\t\t\t * some ET_EXEC (e.g. ia64) may have large virtual\n\t\t\t * memory holes between LOADs.\n\t\t\t *\n\t\t\t */\n\t\t\ttotal_size = total_mapping_size(elf_phdata,\n\t\t\t\t\t\t\telf_ex->e_phnum);\n\t\t\tif (!total_size) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Calculate any requested alignment. */\n\t\t\talignment = maximum_alignment(elf_phdata, elf_ex->e_phnum);\n\n\t\t\t/**\n\t\t\t * DOC: PIE handling\n\t\t\t *\n\t\t\t * There are effectively two types of ET_DYN ELF\n\t\t\t * binaries: programs (i.e. PIE: ET_DYN with\n\t\t\t * PT_INTERP) and loaders (i.e. static PIE: ET_DYN\n\t\t\t * without PT_INTERP, usually the ELF interpreter\n\t\t\t * itself). Loaders must be loaded away from programs\n\t\t\t * since the program may otherwise collide with the\n\t\t\t * loader (especially for ET_EXEC which does not have\n\t\t\t * a randomized position).\n\t\t\t *\n\t\t\t * For example, to handle invocations of\n\t\t\t * \"./ld.so someprog\" to test out a new version of\n\t\t\t * the loader, the subsequent program that the\n\t\t\t * loader loads must avoid the loader itself, so\n\t\t\t * they cannot share the same load range. Sufficient\n\t\t\t * room for the brk must be allocated with the\n\t\t\t * loader as well, since brk must be available with\n\t\t\t * the loader.\n\t\t\t *\n\t\t\t * Therefore, programs are loaded offset from\n\t\t\t * ELF_ET_DYN_BASE and loaders are loaded into the\n\t\t\t * independently randomized mmap region (0 load_bias\n\t\t\t * without MAP_FIXED nor MAP_FIXED_NOREPLACE).\n\t\t\t *\n\t\t\t * See below for \"brk\" handling details, which is\n\t\t\t * also affected by program vs loader and ASLR.\n\t\t\t */\n\t\t\tif (interpreter) {\n\t\t\t\t/* On ET_DYN with PT_INTERP, we do the ASLR. */\n\t\t\t\tload_bias = ELF_ET_DYN_BASE;\n\t\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\t\tload_bias += arch_mmap_rnd();\n\t\t\t\t/* Adjust alignment as requested. */\n\t\t\t\tif (alignment)\n\t\t\t\t\tload_bias &= ~(alignment - 1);\n\t\t\t\telf_flags |= MAP_FIXED_NOREPLACE;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * For ET_DYN without PT_INTERP, we rely on\n\t\t\t\t * the architectures's (potentially ASLR) mmap\n\t\t\t\t * base address (via a load_bias of 0).\n\t\t\t\t *\n\t\t\t\t * When a large alignment is requested, we\n\t\t\t\t * must do the allocation at address \"0\" right\n\t\t\t\t * now to discover where things will load so\n\t\t\t\t * that we can adjust the resulting alignment.\n\t\t\t\t * In this case (load_bias != 0), we can use\n\t\t\t\t * MAP_FIXED_NOREPLACE to make sure the mapping\n\t\t\t\t * doesn't collide with anything.\n\t\t\t\t */\n\t\t\t\tif (alignment > ELF_MIN_ALIGN) {\n\t\t\t\t\tload_bias = elf_load(bprm->file, 0, elf_ppnt,\n\t\t\t\t\t\t\t     elf_prot, elf_flags, total_size);\n\t\t\t\t\tif (BAD_ADDR(load_bias)) {\n\t\t\t\t\t\tretval = IS_ERR_VALUE(load_bias) ?\n\t\t\t\t\t\t\t PTR_ERR((void*)load_bias) : -EINVAL;\n\t\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\t\t}\n\t\t\t\t\tvm_munmap(load_bias, total_size);\n\t\t\t\t\t/* Adjust alignment as requested. */\n\t\t\t\t\tif (alignment)\n\t\t\t\t\t\tload_bias &= ~(alignment - 1);\n\t\t\t\t\telf_flags |= MAP_FIXED_NOREPLACE;\n\t\t\t\t} else\n\t\t\t\t\tload_bias = 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Since load_bias is used for all subsequent loading\n\t\t\t * calculations, we must lower it by the first vaddr\n\t\t\t * so that the remaining calculations based on the\n\t\t\t * ELF vaddrs will be correctly offset. The result\n\t\t\t * is then page aligned.\n\t\t\t */\n\t\t\tload_bias = ELF_PAGESTART(load_bias - vaddr);\n\t\t}\n\n\t\terror = elf_load(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, total_size);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR_VALUE(error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (first_pt_load) {\n\t\t\tfirst_pt_load = 0;\n\t\t\tif (elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Figure out which segment in the file contains the Program\n\t\t * Header table, and map to the associated memory address.\n\t\t */\n\t\tif (elf_ppnt->p_offset <= elf_ex->e_phoff &&\n\t\t    elf_ex->e_phoff < elf_ppnt->p_offset + elf_ppnt->p_filesz) {\n\t\t\tphdr_addr = elf_ex->e_phoff - elf_ppnt->p_offset +\n\t\t\t\t    elf_ppnt->p_vaddr;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif ((elf_ppnt->p_flags & PF_X) && k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\te_entry = elf_ex->e_entry + load_bias;\n\tphdr_addr += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\tif (interpreter) {\n\t\telf_entry = load_elf_interp(interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    load_bias, interp_elf_phdata,\n\t\t\t\t\t    &arch_state);\n\t\tif (!IS_ERR_VALUE(elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += interp_elf_ex->e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR_VALUE(elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\texe_file_allow_write_access(interpreter);\n\t\tfput(interpreter);\n\n\t\tkfree(interp_elf_ex);\n\t\tkfree(interp_elf_phdata);\n\t} else {\n\t\telf_entry = e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = ARCH_SETUP_ADDITIONAL_PAGES(bprm, elf_ex, !!interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tretval = create_elf_tables(bprm, elf_ex, interp_load_addr,\n\t\t\t\t   e_entry, phdr_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tmm = current->mm;\n\tmm->end_code = end_code;\n\tmm->start_code = start_code;\n\tmm->start_data = start_data;\n\tmm->end_data = end_data;\n\tmm->start_stack = bprm->p;\n\n\t/**\n\t * DOC: \"brk\" handling\n\t *\n\t * For architectures with ELF randomization, when executing a\n\t * loader directly (i.e. static PIE: ET_DYN without PT_INTERP),\n\t * move the brk area out of the mmap region and into the unused\n\t * ELF_ET_DYN_BASE region. Since \"brk\" grows up it may collide\n\t * early with the stack growing down or other regions being put\n\t * into the mmap region by the kernel (e.g. vdso).\n\t *\n\t * In the CONFIG_COMPAT_BRK case, though, everything is turned\n\t * off because we're not allowed to move the brk at all.\n\t */\n\tif (!IS_ENABLED(CONFIG_COMPAT_BRK) &&\n\t    IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &&\n\t    elf_ex->e_type == ET_DYN && !interpreter) {\n\t\telf_brk = ELF_ET_DYN_BASE;\n\t\t/* This counts as moving the brk, so let brk(2) know. */\n\t\tbrk_moved = true;\n\t}\n\tmm->start_brk = mm->brk = ELF_PAGEALIGN(elf_brk);\n\n\tif ((current->flags & PF_RANDOMIZE) && snapshot_randomize_va_space > 1) {\n\t\t/*\n\t\t * If we didn't move the brk to ELF_ET_DYN_BASE (above),\n\t\t * leave a gap between .bss and brk.\n\t\t */\n\t\tif (!brk_moved)\n\t\t\tmm->brk = mm->start_brk = mm->brk + PAGE_SIZE;\n\n\t\tmm->brk = mm->start_brk = arch_randomize_brk(mm);\n\t\tbrk_moved = true;\n\t}\n\n#ifdef compat_brk_randomized\n\tif (brk_moved)\n\t\tcurrent->brk_randomized = 1;\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\n\t\tretval = do_mseal(0, PAGE_SIZE, 0);\n\t\tif (retval)\n\t\t\tpr_warn_ratelimited(\"pid=%d, couldn't seal address 0, ret=%d.\n\",\n\t\t\t\t\t    task_pid_nr(current), retval);\n\t}\n\n\tregs = current_pt_regs();\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tfinalize_exec(bprm);\n\tSTART_THREAD(elf_ex, regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_ex);\n\tkfree(interp_elf_phdata);\nout_free_file:\n\texe_file_allow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}"
    }
]